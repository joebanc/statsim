// StatSimConn.cpp : implementation file
//

#include "stdafx.h"
#include "StatSimAPI.h"
#include "StatSimConn.h"
#include "SSVariants.h"
#include "StatSimWnd.h"
#include "statsimdaelib.h"
#include "stxutif.h"

#ifndef STATSIMRS
	#include "statsimrs.h"
#endif

#ifndef DAEDATA
	#include "daedata.h"
#endif

#ifndef DAEDICT
	#include "daedict.h"
#endif

#define _1MB		1
#define _2MB		2
#define _3MB		3
#define _4MB		4
#define _5MB		5
#define _6MB		6
#define _7MB		7
#define _8MB		8

#define MAX_COL_MDB	255

// CSSODBCconn

//////////////////////////////////////////////////////////////////////
// Construction/Destruction - StatSimConn
//////////////////////////////////////////////////////////////////////

//LOCALE
using namespace std;
using namespace gel;

CSSODBCconn::CSSODBCconn()
{

}

CSSODBCconn::CSSODBCconn(CString custUser, CString custPwd,
					   CString custHost, CString custPort, LPCSTR custDB, bool IsMySQL)
{
	m_IsMySQL = IsMySQL;

	ConnectMySQL(custUser, custPwd, custHost, custPort, (CString) custDB);

}

CSSODBCconn::CSSODBCconn(CString strDriver, CString strUser, CString strPwd,
					   CString strServer,  CString strDB,  CString strOpt, bool IsMySQL)
{

	m_IsMySQL = IsMySQL;

	//custom connection
	CString strConn = _T ("Driver={") + strDriver + _T("};\
			Server=") + strServer + _T(";Option=") + strOpt + _T(";\
			Database=") + strDB + _T(";\
			Uid=") + strUser + _T(";\
			Pwd=") + strPwd +_T(";");

	Connect(strConn);

}

CSSODBCconn::CSSODBCconn(CString strConn, bool IsMySQL)
{

	m_IsMySQL = IsMySQL;
	//custom connection
	Connect(strConn);

}


CSSODBCconn::~CSSODBCconn()
{
	Close();

}

LPCSTR CSSODBCconn::sSQLCreateTable(CStatSimRS * pFromRS, CString TableName, 
							 BOOL c, BOOL tE, BOOL eF)
{
	try
	{	
		CString sSQLExec, fldName, sfldType;
		int fldType = 0;
		long fldSize = 0;

		if (tE)
			sSQLExec = _T("CREATE TABLE IF NOT EXISTS `") + TableName + _T("` (`");
		else
			sSQLExec = _T("CREATE TABLE `") + TableName + _T("` (`");

		long ct = pFromRS->GetRecordCount();

		if (ct>0) {
			pFromRS->MoveFirst();
		}

		UINT nCols;

		//check column limit

		if (m_IsMySQL){
			nCols = pFromRS->GetFieldCount();
		}
		else {
			if (pFromRS->GetFieldCount()<=MAX_COL_MDB) {
				nCols = pFromRS->GetFieldCount();
			}
			else {
				nCols = MAX_COL_MDB;
				CString msg;
				msg.Format(_T("Warning: Only %d columns of %d could be transferred to the current database."), 
					MAX_COL_MDB, pFromRS->GetFieldCount() );
				AfxMessageBox(msg);
			}
		}


		for (UINT j=0; j<nCols; j++)
		{
			fldName = pFromRS->GetFieldName(j);

			sfldType = pFromRS->SQLFldType(j, c);
			
			if (j == (nCols - 1)) {
				sSQLExec = sSQLExec + fldName + _T("` ") + sfldType + _T(")");
			}
			else {
				sSQLExec = sSQLExec + fldName + _T("` ") + sfldType + _T(", `");
			}

		}
		
		if (!eF)
			sSQLExec.Replace( _T("`"), _T("") );
		
		sSQLExec = sSQLExec + _T(";");

		//FILE *pFile = fopen("d:\\mysql.sql", "w");
		//fprintf( pFile, ConstChar(sSQLExec) );
		//fclose(pFile);

		return ConstChar(sSQLExec);

	}
	
	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}
}
short CSSODBCconn::ExecuteSQL(CString sSQL, BOOL prompt)
{
	TRY
	{
		CDatabase::ExecuteSQL(sSQL);
		return SQL_SUCCESS;
	}
	
	CATCH(CDBException, e)
	{
		if (prompt)
			AfxMessageBox(e->m_strError);
		return e->m_nRetCode;
	}
	
	END_CATCH

}

int CSSODBCconn::ConnectMySQL(CString currUser, CString currPwd,
					   CString custHost, CString custPort, CString custDB)
{

	//mySQL connection, custom user/pwd
	CString strConn = _T("Driver={MySQL ODBC 3.51 Driver};\
			Server=") + custHost + _T(";Option=16834;\
			Uid=") + currUser + _T(";\
			Pwd=") + currPwd +_T(";");

			/*"Database=") + custDB + _T(";"\*/

	int conVal = Connect(strConn);

	if (conVal>=1000 || conVal==0) 
		Connected = FALSE;
	else
		Connected = TRUE;

	CString sSQL;
	sSQL.Format(_T("CREATE DATABASE IF NOT EXISTS `%s`;"), custDB);
	ExecuteSQL(sSQL);
	sSQL.Format(_T("USE `%s`;"), custDB);
	ExecuteSQL(sSQL);

	return conVal;

}

int CSSODBCconn::Connect(CString strConn)
{

	TRY
	{
		
		//general connection
		return OpenEx(strConn, CDatabase::noOdbcDialog);
	}
	
	CATCH(CDBException, e)
	{
		AfxMessageBox(e->m_strError);
		return e->m_nRetCode;
	}
	
	END_CATCH

}

void CSSODBCconn::CreateTable(CStatSimRS * pFromRS, CString TableName, 
							 BOOL c, BOOL tE, BOOL eF)
{
	try
	{	
		CString sSQLExec(sSQLCreateTable(pFromRS, TableName, c, tE, eF));

		//AfxMessageBox(sSQLExec);
		if (m_IsMySQL) {
			sSQLExec.Replace( _T(";"), _T(" ENGINE=MYISAM;") );
		}

		ExecuteSQL(sSQLExec, FALSE);

	}
	
	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}
}

CString CSSODBCconn::CreateSQL(USHORT index)
{
	return sSQL[index];
}

void CSSODBCconn::CreateSQL(daedata *pFromDta, LPCSTR* TableName, 
								   LPCSTR* pType, USHORT nTypes, CString strIndex)
{
	strIndex.TrimLeft(); strIndex.TrimRight();
	sSQL.SetSize(nTypes);

	CStringArray sSQLExec, SQLtable, 
		fldName, sfldType, sfldSize, sfldDec, sfldUnsigned, sfldZerofill;

	sSQLExec.SetSize(nTypes);
	SQLtable.SetSize(nTypes);
	fldName.SetSize(nTypes);
	sfldType.SetSize(nTypes);
	sfldSize.SetSize(nTypes);
	sfldDec.SetSize(nTypes);
	sfldUnsigned.SetSize(nTypes);
	sfldZerofill.SetSize(nTypes);
	
	UINT *dec, *nFields;
	BOOL *nosign, *zerofill;

	dec = new UINT[nTypes];
	nFields = new UINT[nTypes];
	nosign = new BOOL[nTypes];
	zerofill = new BOOL[nTypes];

	for (USHORT k=0; k<nTypes; k++) {

		SQLtable[k] = TableName[k];	//pass table
		
		sSQLExec[k] = _T("CREATE TABLE IF NOT EXISTS `") + SQLtable[k] + _T("` (`");
		
		nFields[k] = pFromDta->pDict[k]->nVars();
		
		for (UINT j=0; j<nFields[k]; j++)	{
			
			fldName[k] = pFromDta->pDict[k]->GetVarName(j);
			sfldType[k] = pFromDta->pDict[k]->GetVarType(j);
			sfldSize[k] = pFromDta->pDict[k]->GetVarLen(j);
			sfldDec[k] = pFromDta->pDict[k]->GetVarPrec(j);
			sfldUnsigned[k] = pFromDta->pDict[k]->GetVarUnsigned(j);
			sfldZerofill[k] = pFromDta->pDict[k]->GetVarZerofill(j);

			sSQLExec[k] = sSQLExec[k] + fldName[k] + "` " + sfldType[k];
			
			dec[k] = _ttoi(sfldDec[k]);
			nosign[k] = _ttoi(sfldUnsigned[k]);
			zerofill[k] = _ttoi(sfldZerofill[k]);
			
			if (dec[k]>0) {
				sSQLExec[k] = sSQLExec[k] + _T("(") + sfldSize[k] + _T(", ") + sfldDec[k] + _T(") ");
			}
			
			else {
				sSQLExec[k] = sSQLExec[k] + _T("(") + sfldSize[k] + _T(") ");
			}

			if (nosign[k]) {
				sSQLExec[k] = sSQLExec[k] + _T(" UNSIGNED");
			}

			if (zerofill[k]) {
				sSQLExec[k] = sSQLExec[k] + _T(" ZEROFILL");
			}
						
			if (j == nFields[k] - 1) {
				if (strIndex.GetLength() > 0) {
					sSQLExec[k] = sSQLExec[k] + _T(", ") + strIndex + _T(")");
				}
				else {
					sSQLExec[k] = sSQLExec[k] + _T(")");
				}
			}
			
			else {
				sSQLExec[k] = sSQLExec[k] + _T(", `");
			}			
		}
		
		if (m_IsMySQL) {
			sSQLExec[k] = sSQLExec[k] + _T("ENGINE=MYISAM;");
		}
		else {
			sSQLExec[k] = sSQLExec[k] + _T(";");
		}


		sSQL[k] = sSQLExec[k];

	}

	delete [] dec;
	delete [] nFields;
	delete [] nosign;
	delete [] zerofill;

}

void CSSODBCconn::CreateTable(daedata *pFromDta, LPCSTR* TableName, 
										LPCSTR* pType, USHORT nTypes, CString strIndex)
{
	CreateSQL(pFromDta, TableName, pType, nTypes, strIndex);
	for (USHORT k=0; k<nTypes; k++) {
		ExecuteSQL(CreateSQL(k));
	}
}

void CSSODBCconn::UpdateRecords(CStatSimRS *pFromRS, CString TargetTable, LPCSTR sWhereFld,
							   CStatSimWnd* pLabel, CStatSimBar* pProgBar)
{

	CString sSQLExec, sSQLInit, sSQLBody, sWhereClause = _T(""), fldName, sqlitem, 
		prCaption;

	sSQLInit = _T("UPDATE `") + TargetTable + _T("` SET ");
	
	if (sWhereFld!=NULL)
		sWhereClause.Format(_T(" WHERE %s="), (CString) sWhereFld);


	int fldType = 0;
	ULONG fldSize = 0;

	ULONG ct = pFromRS->GetRecordCount();

	//counters
	ULONG counter = 0, max = ct;
	USHORT min = 0;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}

	if (ct>0) {
		pFromRS->MoveFirst();
	}

	try
	{	
		//construct SQL for the fields and records
		for (ULONG i=0; i<(ULONG)pFromRS->GetRecordCount(); i++) {
			for (UINT j=0; j<(UINT)pFromRS->GetFieldCount(); j++) {
				fldName = pFromRS->GetFieldName(j);
				
				if (j==0)
					sSQLBody = _T("`") + fldName + _T("`=");
				else
					sSQLBody = sSQLBody + _T(", `") + fldName + _T("`=");
				
				counter++;
				
				prCaption.Format(_T("StatSim: Updating record %d of %d to %s"), 
					i+1, ct, TargetTable);
				m_sProgress = ConstChar(prCaption);		
				m_nPercent = ((float) (i+1)/(float) ct)*100;

				if (pLabel!=NULL) {
					if (pLabel->GetSafeHwnd()) pLabel->SetText(ConstChar(prCaption));
				}
				
				if (pProgBar!=NULL) {
					if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);
				}
				
				//construct SQL for updating cases			
				sqlitem = pFromRS->SQLFldValue(j, (CString) "\"\"");
				//sqlitem.Replace("\\", "\\\\");

				sSQLBody = sSQLBody + sqlitem;
			}

			sSQLExec = sSQLInit + sSQLBody
				+ sWhereClause + pFromRS->SQLFldValue(sWhereFld, (CString) "\"\"") + _T(";");

			ExecuteSQL(sSQLExec);

			sSQLExec = _T("");
			
			pFromRS->MoveNext();
			
		}		

	}


	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}

}


void CSSODBCconn::InsertRecords(CStatSimRS *pFromRS, CString TargetTable,
							   CStatSimWnd* pLabel, CStatSimBar* pProgBar,
							   BOOL fresh, BOOL single, BOOL ignore,
							   LPCSTR sCritFld, LPCSTR* sCritVals, int nItems)
{

	CString sSQLExec, sSQLInit = _T(""), 
		sSQLField = _T(""), 
		sSQLValue = _T(""), 
		sSQLClause = _T(""), 
		fldName, sqlitem, 
		sAlias, prCaption;

	//test for number of records
	CStatSimRS *pRS = new CStatSimRS(this, ConstChar(TargetTable));
	if (pRS->GetRecordCount()>0 && fresh==TRUE)
		return;
	delete pRS; pRS = NULL;

	if (ignore) {
		sSQLInit = _T("INSERT IGNORE INTO `") + TargetTable + _T("`(");
	}
	else {
		sSQLInit = _T("INSERT INTO `") + TargetTable + _T("`(");
	}

	int fldType = 0;
	ULONG fldSize = 0;

	ULONG ct = pFromRS->GetRecordCount();

	//counters
	ULONG counter = 0, max = ct;
	USHORT min = 0;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}

	if (ct>0) {
		pFromRS->MoveFirst();
	}

	try
	{	
		UINT nCols;

		//check column limit

		if (m_IsMySQL){
			nCols = pFromRS->GetFieldCount();
		}
		else {
			if (pFromRS->GetFieldCount()<=MAX_COL_MDB) {
				nCols = pFromRS->GetFieldCount();
			}
			else {
				nCols = MAX_COL_MDB;
				CString msg;
				msg.Format(_T("Warning: Only %d columns of %d could be transferred to the current database."), 
					MAX_COL_MDB, pFromRS->GetFieldCount() );
				AfxMessageBox(msg);
			}
		}


		//construct SQL for the fields
		for (UINT j=0; j<nCols; j++) {
			
			fldName = pFromRS->GetFieldName(j);
			
			if ( j==nCols-1 )
				sSQLField = sSQLField + _T("`") + fldName + _T("`) \nVALUES ");
			else
				sSQLField = sSQLField + _T("`") + fldName + _T("`, ");
		
		}
		
		for (ULONG i=0; i<(ULONG)pFromRS->GetRecordCount(); i++) {			
	
			if (sCritFld!=NULL && sCritVals!=NULL) {
				LPCSTR sCrit = ConstChar( pFromRS->SQLFldValue(sCritFld) );
				if ( !Exists(sCritVals, sCrit, nItems) ) {
					pFromRS->MoveNext();
					continue;
				}
			}

			counter++;
			
			prCaption.Format(_T("StatSim: Inserting record %d of %d to %s"), 
				counter, max, TargetTable);
			m_sProgress = ConstChar(prCaption);		
			m_nPercent = ((float) (counter)/(float) max)*100;

			if (pLabel!=NULL) {
				if (pLabel->GetSafeHwnd()) pLabel->SetText( ConstChar(prCaption) );
			}				
			
			if (pProgBar!=NULL) {
				if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);
			}
			
			//construct SQL for adding cases
			for (UINT j=0; j<(UINT)nCols; j++) {
		
				if (single) {
					//temporary handler
					CString sTemp = pFromRS->SQLFldValue(j, (CString) "\'\'", TRUE, TRUE);
					int sLen = sTemp.GetLength();

					//get the enclosed string
					//pass new stemp
					if (sTemp.Left(1)=="'" && sTemp.Right(1)=="'") {
						sTemp = sTemp.Left(sLen-1);
						sLen = sTemp.GetLength();
						sTemp = sTemp.Right(sLen-1);
						
						//this is for ms jet that cannot insert single quotes
						sTemp.Replace( _T("'"), _T("''") );
						
						//reassign
						sqlitem = _T("'") + sTemp + _T("'");
					}
					else {
						sqlitem = sTemp;
					}

				}

				else {
					sqlitem = pFromRS->SQLFldValue(j, (CString) "\"\"");
				}
								
				//appendages
				if (j == 0) {
					
					sSQLClause = sSQLClause + _T("(") + sqlitem + _T(", ");

				}
				//if there is only one field
				else if ((j == nCols - 1) ||
					(nCols - 1 == 0)) {
					
					sSQLClause = sSQLClause + sqlitem + _T(")");

				}				
				else {
					sSQLClause = sSQLClause + sqlitem + _T(", ");
				}		

				//AfxMessageBox(sSQLClause);

			}
					
			pFromRS->MoveNext();

			if (single) {
				sSQLClause = sSQLClause + _T(";\n");
				sSQLExec = sSQLInit + sSQLField + sSQLClause;
				
				ExecuteSQL( (sSQLExec) );

				sSQLExec = _T("");
				sSQLClause = _T("");
			}
			else {
				if (counter>1) {
					sSQLValue = sSQLValue + _T(", \n") + sSQLClause;
					sSQLClause = _T("");
				}
				else {
					sSQLValue = sSQLClause;
					sSQLClause = _T("");
				}
			}
		}

		sSQLExec = sSQLInit + sSQLField + sSQLValue + _T(";");
				
		if (!single)
			ExecuteSQL( (sSQLExec) );
		

	}


	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}

}
void CSSODBCconn::CreateTable(LPCSTR TargetTable, int nCols, LPCSTR** sColInfo, BOOL testExist)
{
	CString sSQL, sClause;

	if (testExist)
		sSQL.Format(_T("CREATE TABLE IF NOT EXISTS `%s` (\n"), (CString) TargetTable);
	else
		sSQL.Format(_T("CREATE TABLE `%s` (\n"), (CString) TargetTable);

	
	for (int j=0; j<nCols; j++) {
		
		if ( j==(nCols-1) )
			sClause.Format(_T("`%s` %s\n)"), (CString) sColInfo[COL_NAME][j], (CString) sColInfo[COL_TYPE][j]);
		else
			sClause.Format(_T("`%s` %s,\n"), (CString) sColInfo[COL_NAME][j], (CString) sColInfo[COL_TYPE][j]);

		sSQL += sClause;

	}

	if (m_IsMySQL) {
		sSQL = sSQL + _T("\nENGINE=MYISAM;");
	}
	else {
		sSQL = sSQL + _T(";");
	}

	//FILE *pFile = _tfopen(_T("C:\\table.sql"), _T("w"));
	//_ftprintf(pFile, ConstChar(sSQL));
	//fclose(pFile);

	ExecuteSQL(sSQL);

}

void CSSODBCconn::InsertRecords(LPCSTR** sArray, LPCSTR TargetTable, 
							  long nRows, int nCols, LPCSTR** sColInfo, 
							  CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
							  BOOL fresh, BOOL single, BOOL ignore)
{
	
	//CreateTable(TargetTable, nCols, sColInfo);

	CString sSQLExec, sSQLInit = _T(""), sSQLField = _T(""), sSQLValue = _T(""), fldName, sqlitem, 
		sAlias, prCaption;

	//test for number of records
	CStatSimRS *pRS = new CStatSimRS(this, TargetTable);
	if (pRS->GetRecordCount()>0 && fresh==TRUE)
		return;
	delete pRS; pRS = NULL;

	if (ignore) {
		sSQLInit = _T("INSERT IGNORE INTO `") + (CString) TargetTable + _T("`(");
	}
	else {
		sSQLInit = _T("INSERT INTO `") + (CString) TargetTable + _T("`(");
	}

	int fldType = 0;
	ULONG fldSize = 0;

	//counters
	ULONG counter = 0, max = nRows;
	USHORT min = 0;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}
	
	UINT nCols_new = 0;
	
	if (!m_IsMySQL){
		if (nCols>=MAX_COL_MDB) {
			nCols_new = MAX_COL_MDB;
			CString msg;
			msg.Format(_T("Warning: Only %d columns of %d could be transferred to the current database."), 
				MAX_COL_MDB, nCols );
			AfxMessageBox(msg);
		}
		else {
			nCols_new = nCols;
		}
	}
	else {
		nCols_new = nCols;
	}
	
	//construct SQL for the fields
	for (UINT j=0; j<nCols_new; j++) {
		
		sColInfo[COL_TYPE][j];
		
		fldName = sColInfo[COL_NAME][j];
		
		if ( j==nCols_new-1 )
			sSQLField = sSQLField + _T("`") + fldName + _T("`) \nVALUES ");
		else
			sSQLField = sSQLField + _T("`") + fldName + _T("`, ");
	
	}
	
	for (ULONG i=0; i<nRows; i++) {
		counter++;
		
		prCaption.Format(_T("StatSim: Inserting record %d of %d to %s"), 
			counter, max, (CString) TargetTable);
		m_sProgress = ConstChar(prCaption);		
		m_nPercent = ((float) counter/(float) max)*100;
		
		if (pLabel!=NULL) {
			if (pLabel->GetSafeHwnd()) pLabel->SetText( ConstChar(prCaption) );
		}				
		
		if (pProgBar!=NULL) {
			if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);			
		}
		
		//construct SQL for adding cases
		for (UINT j=0; j<(UINT)nCols_new; j++) {
			
			if (single) {
				//temporary handler
				CString sTemp( sArray[i][j] );
				
				if (strcmp(sColInfo[COL_NUM][j], NUMERIC)!=0) { //compare
					sTemp.Replace(_T("\\"), _T("\\\\"));	//replace backslash
					//sTemp.Replace(_T("\'"), _T("\\\'"));	//replace single quotes
					sTemp = _T("\'") + sTemp + _T("\'");
				}

				int sLen = sTemp.GetLength();

				//get the enclosed string
				//pass new stemp
				if (sTemp.Left(1)=="'" && sTemp.Right(1)=="'") {
					sTemp = sTemp.Left(sLen-1);
					sLen = sTemp.GetLength();
					sTemp = sTemp.Right(sLen-1);
					
					//this is for ms jet that cannot insert single quotes
					sTemp.Replace( _T("'"), _T("''") );
					
					//reassign
					sqlitem = _T("'") + sTemp + _T("'");
				}
				else {
					sqlitem = sTemp;
				}
			}
			
			else {
				//temporary handler
				sqlitem = sArray[i][j];

				if (strcmp(sColInfo[COL_NUM][j], NUMERIC)!=0) { //compare
					sqlitem.Replace(_T("\\"), _T("\\\\"));	//replace backslash
					//sTemp.Replace(_T("\'"), _T("\\\'"));	//replace single quotes
					sqlitem = _T("\"") + sqlitem + _T("\"");
				}
			}
			//appendages
			if (j == 0) {
				sSQLValue = sSQLValue + _T("(") + sqlitem + _T(", ");
			}
			
			//if there is only one field
			else if ((j == nCols_new - 1) || 
				(nCols_new - 1 == 0)) {
				sSQLValue = sSQLValue + sqlitem + _T(")");
			}
			
			else {
			
				sSQLValue = sSQLValue + sqlitem + _T(", ");
			
			}
		}
		
		if ( i < (nRows-1) ) { //not EOF
			if (single) {
				sSQLValue = sSQLValue + _T(";\n");
				sSQLExec = sSQLInit + sSQLField + sSQLValue;
				
				//FILE *pFile = _tfopen(_T("C:\\insert.sql"), _T("w"));
				//_ftprintf(pFile, ConstChar(sSQLExec));
				//fclose(pFile);

				ExecuteSQL( sSQLExec );
				sSQLExec = _T("");
				sSQLValue = _T("");
			}
			else {
				sSQLValue = sSQLValue + _T(", \n");
			}
		}
		else {
			if (single) {
				sSQLValue = sSQLValue + _T(";\n");
				sSQLExec = sSQLInit + sSQLField + sSQLValue;
				
				ExecuteSQL( sSQLExec );
				sSQLExec = _T("");
				sSQLValue = _T("");
				
			}
			
			else {
				sSQLValue = sSQLValue + _T(";\n");
			}				
		}
	}
	
	sSQLExec = sSQLInit + sSQLField + sSQLValue;
	if (!single)
		ExecuteSQL( (sSQLExec) );

}
void CSSODBCconn::InsertRecords(daedata * pFromDta, LPCSTR* TargetTable, 
							   LPCSTR* pType, USHORT nTypes, 
							   CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
							   float limitMB, CString strIndex)
{
	//create table if necessary	
	CreateTable(pFromDta, TargetTable, pType, nTypes, strIndex);	
	
	CStringArray sSQLPacketAdj, sSQLInit, sSQLClause, sSQLFullClause, 
		sSQLClauseBch, sSQLExec, sSQLExecBch;

	sSQLPacketAdj.SetSize(nTypes);
	sSQLInit.SetSize(nTypes);
	sSQLClause.SetSize(nTypes);
	sSQLFullClause.SetSize(nTypes);
	sSQLClauseBch.SetSize(nTypes);
	sSQLExec.SetSize(nTypes);
	sSQLExecBch.SetSize(nTypes);

	CStringArray SQLtable, fldName, sqlitem, prCaption;

	SQLtable.SetSize(nTypes);
	fldName.SetSize(nTypes);
	sqlitem.SetSize(nTypes);
	prCaption.SetSize(nTypes);

	UINT *nCols, *nRows;
	ULONG *i, *j;

	nCols = new UINT[nTypes];
	nRows = new UINT[nTypes];
	i = new ULONG[nTypes];
	j = new ULONG[nTypes];
	
	//packet size settings////////////////////////////////////////////
	
	float bchlimit = limitMB*( pow( (float) 1024, (float) 2 ) );
	
	if (limitMB>1) {
		
		CString mapSQL;	
		mapSQL.Format(_T("SET max_allowed_packet = %d"), (ULONG) bchlimit);
		ExecuteSQL(mapSQL);

		AfxMessageBox(mapSQL);
	}

	//packet size settings////////////////////////////////////////////

	USHORT min = 0, batch = 0;
	
	//counters
	ULONG counter = 0, bchpacket, packet,
		max = pFromDta->nLines;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}
	/*
	if (!pLabel && !pProgBar) {
		CSphereProgress *pSphereProgress = new CSphereProgress;
	}
	*/


	for (USHORT k=0; k<nTypes; k++) {	
		sSQLPacketAdj[k] = _T("");
		sSQLInit[k] = _T("");
		sSQLClause[k] = _T("");
		sSQLFullClause[k] = _T("");
		sSQLClauseBch[k] = _T("");
		sSQLExec[k] = _T("");
		sSQLExecBch[k] = _T("");
		
		nCols[k] = pFromDta->colSize[k];
		nRows[k] = pFromDta->rowSize[k];

		SQLtable[k] = TargetTable[k];
		
		sSQLInit[k] = _T("INSERT INTO `") + SQLtable[k] + _T("`(`");
		
		//construct SQL for the fields
		
		for (ULONG b=0; b<nCols[k]; b++) {
			
			fldName[k] = pFromDta->pDict[k]->GetVarName(b);
			//packet = packet + pFromDta->pDict->GetVarBytes(j);	//inconsistent
			
			if (b == nCols[k] - 1) {
				sSQLInit[k] = sSQLInit[k] + fldName[k] + _T("`) \nVALUES ");
			}
			else {
				sSQLInit[k] = sSQLInit[k] + fldName[k] + _T("`,`");
			}
		}
		
		//AfxMessageBox(sSQLInit[k]);
		//bchpacket = packet;				//inconsistent
		//ensure initiated
		i[k]=0, j[k]=0;
		
		for (i[k]=0; i[k]<nRows[k]; i[k]++) {	
			//Reassign initial SQL to prepare for another record
			//reinitialize
			sSQLClause[k] = _T("");
			counter++; //batch++;
			//bchpacket = counter * packet; 			//inconsistent				
			
			prCaption[k].Format(_T("StatSim: Inserting record %d of %d to %s"), 
				i[k]+1, nRows[k], SQLtable[k]);
			
			m_sProgress = ConstChar(prCaption[k]);		
			m_nPercent = ((float) counter/(float) max)*100;

			if (pLabel!=NULL) {
				if (pLabel->GetSafeHwnd()) pLabel->SetText( ConstChar(prCaption[k]) );
			}				
			
			if (pProgBar!=NULL) {
				if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);
			}

			/*
			if (!pLabel && !pProgBar) {

				if(!pSphereProgress->Continue())
					return 1;
				CString strMessage;
				strMessage.Format(L"Progress: %i", m_nPercent);
				pSphereProgress->SetProgress(strMessage, (double)i/50.0f);
			}
			*/


			//construct SQL for adding cases
			for (j[k]=0; j[k]<nCols[k]; j[k]++) {
				
				sqlitem[k] = pFromDta->SQLItemValue(k, i[k], j[k], "\"\"")->c_str();	
				//AfxMessageBox(sqlitem[k]);
							
				//appendages
				if (nCols[k]==1) {
					sSQLClause[k] = _T("(") + sqlitem[k] + _T(")");
				}
				
				else {
					if (j[k] == 0) {
						sSQLClause[k] = _T("(") + sqlitem[k] + _T(",");					
					}
					else if (j[k] == (nCols[k] - 1)) {
						sSQLClause[k] = sSQLClause[k] + sqlitem[k] + _T(")");
					}				
					else {
						sSQLClause[k] = sSQLClause[k] + sqlitem[k] + _T(",");
					}
				}
			}
	
			sSQLExecBch[k] = sSQLInit[k] + sSQLClauseBch[k];
			
			packet = sSQLExecBch[k].GetLength();	//get the size of the previous full batch SQL
			bchpacket = sSQLClause[k].GetLength();	//get the size of the current clause
			
			if ( packet + bchpacket > (bchlimit-8) ) {
				sSQLExecBch[k] = sSQLExecBch[k] + _T(";\n");
							
				//AfxMessageBox(sSQLExecBch[k]);
				ExecuteSQL(sSQLExecBch[k]);
				
				sSQLExecBch[k] = _T("");	//reset
				sSQLClauseBch[k] = _T("");	//reset
				
				//reassign current clause since it is not included in the execution
				sSQLClauseBch[k] = sSQLClauseBch[k] + sSQLClause[k];
			}
			
			else {
				
				if (i[k] == nRows[k]-1) {

					if (nRows[k]==1) {
						sSQLExecBch[k] = sSQLExecBch[k] + sSQLClause[k] + _T(";\n");

						//CString filename;
						//filename.Format(_T("c:\\append%d.sql", k);
						//FILE *pFile = fopen(filename, "w");
						//fprintf(pFile, sSQLExecBch[k]);
						
						
						//AfxMessageBox(sSQLExecBch[k]);						
						ExecuteSQL(sSQLExecBch[k]);
						sSQLExecBch[k] = _T("");	//reset
						sSQLClauseBch[k] = _T("");	//reset
					
					}

					else {
						//append the last clause						
						sSQLExecBch[k] = sSQLExecBch[k] + _T(",\n") + sSQLClause[k] + _T(";\n");
											
						//CString filename;
						//filename.Format(_T("c:\\append%d.sql", k);
						//FILE *pFile = fopen(filename, "w");
						//fprintf(pFile, sSQLExecBch[k]);
						
						//AfxMessageBox(sSQLExecBch[k]);
						ExecuteSQL(sSQLExecBch[k]);
						sSQLExecBch[k] = _T("");	//reset
						sSQLClauseBch[k] = _T("");	//reset
					}
				}
				
				else {
					
					if (i[k]==0) {
						sSQLClauseBch[k] = sSQLClauseBch[k] + sSQLClause[k];
					}
					else {
						sSQLClauseBch[k] = sSQLClauseBch[k] + ",\n" + sSQLClause[k];
					}
				
				}
			}
		}
	}
	
	delete [] nCols;
	delete [] nRows;
	delete [] i;
	delete [] j;

}

bool CSSODBCconn::IsConnected()
{

	return Connected;

}
//MySQL Specific

CSSMySQLconn::CSSMySQLconn(bool IsMySQL = true):m_IsMySQL(IsMySQL)
{

}

CSSMySQLconn::CSSMySQLconn(CString custUser, CString custPwd,
					   CString custHost, CString custPort, LPCSTR custDB, bool IsMySQL):m_IsMySQL(IsMySQL)
{

	Connect(custUser, custPwd, custHost, custPort, (CString) custDB);


}


CSSMySQLconn::~CSSMySQLconn()
{

	if (SSQuery!=NULL) {
		SSQuery->reset();
		delete SSQuery; SSQuery = NULL;
	}
	if (SSResult!=NULL) {
		SSResult->clear();
		delete SSResult; SSResult = NULL;
	}

}


int CSSMySQLconn::Connect(CString currUser, CString currPwd,
					   CString custHost, CString custPort, CString custDB)
{

	int nRetCode = 0;
	CString strMsg, str1, str2;
	
	// TODO: code your application's behavior here.
	// The full format for the Connection constructor is
	// Connection(cchar *db, cchar *host="", 
	//            cchar *user="", cchar *passwd="") 		
	// You may need to specify some of them if the database is not on
	// the local machine or you database username is not the same as your
	// login name, etc..
	
	try {

		_tochar host(custHost),
			user(currUser),
			pwd(currPwd),
			dbTemp(custDB),
			port(custPort);
		unsigned int uintport= (unsigned int) atoi(port);

		std::string db(dbTemp);

		connect( "", host, user, pwd, uintport );
		
		SSQuery = new mysqlpp::Query(this);
		// This creates a query object that is bound to this connection.

		SSResult = new mysqlpp::StoreQueryResult;
		// This creates a query object that is bound to this connection.

		CString sSQL = _T("CREATE DATABASE IF NOT EXISTS `") + custDB + _T("`;");
		ExecuteSQL( sSQL );
	
		//set database
		//int len = custDB.GetLength();
		//select_db( W2CA(custDB.GetBuffer(len)) );
		select_db( db );
			
	}
	catch (mysqlpp::ConnectionFailed er) { //handle connection error
		cerr << /*"Error: "*/ "" << er.what() <<  endl;
		
		str1 = er.what();			
		strMsg = _T(/*"Error: "*/ "") + str1;
		AfxMessageBox(strMsg);
		
		nRetCode = -1;  
	} 

	catch (mysqlpp::BadQuery er){ // handle any connection 
		// or query errors that may come up
		cerr << /*"Error: "*/ "" << er.what() <<  endl;
		
		str1 = er.what();			
		strMsg = _T(/*"Error: "*/ "") + str1;
		AfxMessageBox(strMsg);
		
		nRetCode = -1;  
	} 
	
	catch (mysqlpp::BadConversion er) {
		// we still need to cache bad conversions incase something goes 
		// wrong when the data is converted into stock
		cerr << "Error: Tried to convert \"" << er.data << "\" to a \""
			<< er.type_name << "\"." << endl;
		
		str1 = er.data.c_str();
		str2 = er.type_name;
		strMsg = _T("Error: Tried to convert ") + str1 + _T(" to a ") + str2 + _T(".");
		
		AfxMessageBox(strMsg);
		
		nRetCode = -1;
	}
	
	return nRetCode;

}

LPCSTR CSSMySQLconn::sSQLCreateTable(CStatSimRS * pFromRS, CString TableName, 
							 BOOL c, BOOL tE, BOOL eF)
{
	try
	{	
		CString sSQLExec, fldName, sfldType;
		int fldType = 0;
		long fldSize = 0;

		if (tE)
			sSQLExec = _T("CREATE TABLE IF NOT EXISTS `") + TableName + _T("` (`");
		else
			sSQLExec = _T("CREATE TABLE `") + TableName + _T("` (`");

		long ct = pFromRS->GetRecordCount();

		if (ct>0) {
			pFromRS->MoveFirst();
		}

		UINT nCols;

		//check column limit

		if (m_IsMySQL){
			nCols = pFromRS->GetFieldCount();
		}
		else {
			if (pFromRS->GetFieldCount()<=MAX_COL_MDB) {
				nCols = pFromRS->GetFieldCount();
			}
			else {
				nCols = MAX_COL_MDB;
				CString msg;
				msg.Format(_T("Warning: Only %d columns of %d could be transferred to the current database."), 
					MAX_COL_MDB, pFromRS->GetFieldCount() );
				AfxMessageBox(msg);
			}
		}


		for (UINT j=0; j<nCols; j++)
		{
			fldName = pFromRS->GetFieldName(j);

			sfldType = pFromRS->SQLFldType(j, c);
			
			if (j == (nCols - 1)) {
				sSQLExec = sSQLExec + fldName + _T("` ") + sfldType + _T(")");
			}
			else {
				sSQLExec = sSQLExec + fldName + _T("` ") + sfldType + _T(", `");
			}

			//AfxMessageBox(sSQLExec);
		}
		
		if (!eF)
			sSQLExec.Replace( _T("`"), _T("") );
	
		if (m_IsMySQL) {
			sSQLExec = sSQLExec + _T("\nENGINE=MYISAM;");
		}
		else {
			sSQLExec = sSQLExec + _T(";");
		}

		//FILE *pFile = fopen("C:\\mysql.sql", "w");
		//fprintf( pFile, ConstChar(sSQLExec) );
		//fclose(pFile);

		return ConstChar(sSQLExec);

	}
	
	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}
}

short CSSMySQLconn::ExecuteSQL(CString sSQL, BOOL prompt)
{

	short nRetCode = 0;
	CString strMsg, str1, str2;

    try {

		//reset if necessary
		if (SSQuery) {
			SSQuery->reset();
		}
		
		//_tochar sql(ConstChar(sSQL));
		*SSQuery << ConstChar(sSQL);
		
		SSQuery->execute();
   		// Query::execute() executes the stored query 


	} 
	
	catch (mysqlpp::BadQuery er){ 
		
		// handle any connection 
		// or query errors that may come up
		cerr << /*"Error: "*/ "" << er.what() <<  endl;

		str1 = er.what();
		strMsg = _T(/*"Error: "*/ "") + str1;
		
		if (prompt)	//to be prompted?
			AfxMessageBox(strMsg);

		nRetCode = -1;
    
	} 
	
	catch (mysqlpp::BadConversion er) {
		// we still need to cache bad conversions incase something goes 
		// wrong when the data is converted into stock
		cerr << "Error: Tried to convert \"" << er.data << "\" to a \""
			<< er.type_name << "\"." << endl;

		str1 = er.data.c_str();
		str2 = er.type_name;
		strMsg = _T("Error: Tried to convert ") + str1 + _T(" to a ") + str2 + _T(".");
		
		if (prompt)	//to be prompted?
			AfxMessageBox(strMsg);

		nRetCode = -1;
    }

	return nRetCode;

}

mysqlpp::StoreQueryResult* CSSMySQLconn::OpenSQL(CString sSQL, BOOL prompt)
{

	mysqlpp::StoreQueryResult* retRes = new mysqlpp::StoreQueryResult;
	CString strMsg, str1, str2;

    try {
		
		//reset if necessary
		if (SSQuery) {
			SSQuery->reset();
		}

		//_tochar sql(ConstChar(sSQL));
		*SSQuery << ConstChar(sSQL);

		*retRes = SSQuery->store();
   		// Query::store() executes and stores the query
    
	}
	
	catch (mysqlpp::BadQuery er){ 
		
		// handle any connection 
		// or query errors that may come up
		cerr << /*"Error: "*/ "" << er.what() <<  endl;

		str1 = er.what();
		strMsg = _T(/*"Error: "*/ "") + str1;
		
		if (prompt)	//to be prompted?
			AfxMessageBox(strMsg);
	
		retRes = NULL;

	} 
	
	catch (mysqlpp::BadConversion er) {
		// we still need to cache bad conversions incase something goes 
		// wrong when the data is converted into stock
		cerr << "Error: Tried to convert \"" << er.data << "\" to a \""
			<< er.type_name << "\"." << endl;

		str1 = er.data.c_str();
		str2 = er.type_name;
		strMsg = _T("Error: Tried to convert ") + str1 + _T(" to a ") + str2 + _T(".");

		if (prompt)	//to be prompted?
			AfxMessageBox(strMsg);

		retRes = NULL;

    }

	return retRes;

}

bool CSSMySQLconn::IsConnected()
{

	return connected();

}

void CSSMySQLconn::CreateTable(CStatSimRS * pFromRS, CString TableName, 
							 BOOL c, BOOL tE, BOOL eF)
{
	try
	{	
		CString sSQLExec( sSQLCreateTable(pFromRS, TableName, c, tE, eF) );
		ExecuteSQL(sSQLExec, FALSE);

	}
	
	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}
}
void CSSMySQLconn::CreateTable(daedata *pFromDta, LPCSTR* TableName, 
										LPCSTR* pType, USHORT nTypes, CString strIndex)
{
	CreateSQL(pFromDta, TableName, pType, nTypes, strIndex);
	for (USHORT k=0; k<nTypes; k++) {
		//CString filename;
		//filename.Format(_T("d:\\create%d.sql"), k);
		//FILE *pFile = _wfopen(filename, L"w");
		//fwprintf(pFile, CreateSQL(k));
		//fclose(pFile);
		//AfxMessageBox(CreateSQL(k));
		ExecuteSQL(CreateSQL(k));
	}
}

void CSSMySQLconn::CreateTable(daedict **pDCT, LPCSTR* TableName, 
										LPCSTR* pType, USHORT nTypes, CString strIndex)
{
	CreateSQL(pDCT, TableName, pType, nTypes, strIndex);
	for (USHORT k=0; k<nTypes; k++) {
		//CString filename;
		//filename.Format(_T("d:\\create%d.sql"), k);
		//FILE *pFile = _wfopen(filename, L"w");
		//fwprintf(pFile, CreateSQL(k));
		//fclose(pFile);
		//AfxMessageBox(CreateSQL(k));
		ExecuteSQL(CreateSQL(k));
	}
}
CString CSSMySQLconn::CreateSQL(USHORT index)
{
	return sSQL[index];
}

void CSSMySQLconn::CreateSQL(daedata *pFromDta, LPCSTR* TableName, 
								   LPCSTR* pType, USHORT nTypes, CString strIndex)
{
	strIndex.TrimLeft(); strIndex.TrimRight();
	sSQL.SetSize(nTypes);

	CStringArray sSQLExec, SQLtable, 
		fldName, sfldType, sfldSize, sfldDec, sfldUnsigned, sfldZerofill;

	sSQLExec.SetSize(nTypes);
	SQLtable.SetSize(nTypes);
	fldName.SetSize(nTypes);
	sfldType.SetSize(nTypes);
	sfldSize.SetSize(nTypes);
	sfldDec.SetSize(nTypes);
	sfldUnsigned.SetSize(nTypes);
	sfldZerofill.SetSize(nTypes);
	
	UINT *dec, *nFields;
	int *fldlen;
	BOOL *nosign, *zerofill;

	dec = new UINT[nTypes];
	fldlen = new int[nTypes];
	nFields = new UINT[nTypes];
	nosign = new BOOL[nTypes];
	zerofill = new BOOL[nTypes];

	for (USHORT k=0; k<nTypes; k++) {

		SQLtable[k] = TableName[k];	//pass table
		
		sSQLExec[k] = _T("CREATE TABLE IF NOT EXISTS `") + SQLtable[k] + _T("` (`");
		
		nFields[k] = pFromDta->pDict[k]->nVars();
		
		for (UINT j=0; j<nFields[k]; j++)	{
			
			fldName[k] = pFromDta->pDict[k]->GetVarName(j);
			sfldType[k] = pFromDta->pDict[k]->GetVarType(j);

			sfldSize[k] = pFromDta->pDict[k]->GetVarLen(j);

			sfldDec[k] = pFromDta->pDict[k]->GetVarPrec(j);
			sfldUnsigned[k] = pFromDta->pDict[k]->GetVarUnsigned(j);
			sfldZerofill[k] = pFromDta->pDict[k]->GetVarZerofill(j);

			sSQLExec[k] = sSQLExec[k] + fldName[k] + "` " + sfldType[k];
			
			dec[k] = _ttoi(sfldDec[k]);
			fldlen[k] = _ttoi(sfldSize[k]);
			nosign[k] = _ttoi(sfldUnsigned[k]);
			zerofill[k] = _ttoi(sfldZerofill[k]);
			
			if (dec[k]>0) { //MDC adjusted
				if (fldlen[k]>0)
					sSQLExec[k] = sSQLExec[k] + _T("(") + sfldSize[k] + _T(", ") + sfldDec[k] + _T(") ");
			}
			
			else {
				if (fldlen[k]>0)
					sSQLExec[k] = sSQLExec[k] + _T("(") + sfldSize[k] + _T(") ");
			}

			if (nosign[k]) {
				sSQLExec[k] = sSQLExec[k] + _T(" UNSIGNED");
			}

			if (zerofill[k]) {
				sSQLExec[k] = sSQLExec[k] + _T(" ZEROFILL");
			}
						
			if (j == nFields[k] - 1) {
				if (strIndex.GetLength() > 0) {
					sSQLExec[k] = sSQLExec[k] + _T(", ") + strIndex + _T(")");
				}
				else {
					sSQLExec[k] = sSQLExec[k] + _T(")");
				}
			}
			
			else {
				sSQLExec[k] = sSQLExec[k] + _T(", `");
			}			
		}
		
		if (m_IsMySQL) {
			sSQLExec[k] = sSQLExec[k] + _T("ENGINE=MYISAM;");
		}
		else {
			sSQLExec[k] = sSQLExec[k] + _T(";");
		}


		sSQL[k] = sSQLExec[k];
	
	}

	delete [] dec;
	delete [] nFields;
	delete [] nosign;
	delete [] zerofill;

}

void CSSMySQLconn::CreateSQL(daedict **pDict, LPCSTR* TableName, 
								   LPCSTR* pType, USHORT nTypes, CString strIndex)
{
	strIndex.TrimLeft(); strIndex.TrimRight();
	sSQL.SetSize(nTypes);

	CStringArray sSQLExec, SQLtable, 
		fldName, sfldType, sfldSize, sfldDec, sfldUnsigned, sfldZerofill;

	sSQLExec.SetSize(nTypes);
	SQLtable.SetSize(nTypes);
	fldName.SetSize(nTypes);
	sfldType.SetSize(nTypes);
	sfldSize.SetSize(nTypes);
	sfldDec.SetSize(nTypes);
	sfldUnsigned.SetSize(nTypes);
	sfldZerofill.SetSize(nTypes);
	
	int *dec, *nFields;
	int *fldlen;
	BOOL *nosign, *zerofill, mdc=FALSE;

	dec = new int[nTypes];
	fldlen = new int[nTypes];
	nFields = new int[nTypes];
	nosign = new BOOL[nTypes];
	zerofill = new BOOL[nTypes];

	for (USHORT k=0; k<nTypes; k++) {

		SQLtable[k] = TableName[k];	//pass table
		
		sSQLExec[k] = _T("CREATE TABLE IF NOT EXISTS `") + SQLtable[k] + _T("` (`");
		
		nFields[k] = pDict[k]->nVars();

		//CString msg;
		//msg.Format(_T("%d: %d fields"), k, nFields[k]);
		//AfxMessageBox(msg);
		
		for (UINT j=0; j<nFields[k]; j++)	{
			
			fldName[k] = pDict[k]->GetVarName(j);
			sfldType[k] = pDict[k]->GetVarType(j);
			sfldSize[k] = pDict[k]->GetVarLen(j);

			//override for hcn
			fldlen[k] = _ttoi(sfldSize[k]);

			if (fldName[k]=="hcn" && fldlen[k]>0) {
				sfldSize[k] = "6"; //override length of hcn
			}

			sfldDec[k] = pDict[k]->GetVarPrec(j);
			sfldUnsigned[k] = pDict[k]->GetVarUnsigned(j);
			sfldZerofill[k] = pDict[k]->GetVarZerofill(j);

			sSQLExec[k] = sSQLExec[k] + fldName[k] + "` " + sfldType[k];
			
			dec[k] = _ttoi(sfldDec[k]);
			nosign[k] = _ttoi(sfldUnsigned[k]);
			zerofill[k] = _ttoi(sfldZerofill[k]);

			//CString msg;
			//msg.Format(_T("%s: %d dec"), fldName[k], dec[k]);
			//AfxMessageBox(msg);

			if (dec[k]>0) { //MDC adjusted
				if (fldlen[k]>0)
					sSQLExec[k] = sSQLExec[k] + _T("(") + sfldSize[k] + _T(", ") + sfldDec[k] + _T(") ");
			}
			else if (dec[k]==0) {
				if (fldlen[k]>0) {
					sSQLExec[k] = sSQLExec[k] + _T("(") + sfldSize[k] + _T(") ");
				}

			}
			else {
				mdc=TRUE; //mobile data capture; temporary	

				if (fldlen[k]>0)
					sSQLExec[k] = sSQLExec[k] + _T("(") + sfldSize[k] + _T(") ");
			}

			if (nosign[k]) {
				sSQLExec[k] = sSQLExec[k] + _T(" UNSIGNED");
			}

			if (zerofill[k]) {
				sSQLExec[k] = sSQLExec[k] + _T(" ZEROFILL");
			}

						
			if (j == nFields[k] - 1) {
				if (strIndex.GetLength() > 0) {
					if (mdc) {
						if (k!=0)
							strIndex.Format(_T("INDEX hpqIndex (%s_id, id)"), SQLtable[0]);  //for mdc; temporary
						else
							strIndex.Format(_T("INDEX hpqIndex (id)"));  //for mdc; temporary
					}
					sSQLExec[k] = sSQLExec[k] + _T(", ") + strIndex + _T(")");
				}
				else {
					sSQLExec[k] = sSQLExec[k] + _T(")");
				}
			}
			
			else {
				sSQLExec[k] = sSQLExec[k] + _T(", `");	//shall this be an else after dec>0 & fldlen>0
				//AfxMessageBox(sSQLExec[k]);
			}			
		}
		
		if (m_IsMySQL) {
			sSQLExec[k] = sSQLExec[k] + _T("ENGINE=MYISAM;");
		}
		else {
			sSQLExec[k] = sSQLExec[k] + _T(";");
		}


		sSQL[k] = sSQLExec[k];
		//AfxMessageBox(sSQL[k]);
		//CString filename;
		//filename.Format(_T("d:\\create%d.sql"), k);
		//FILE *pFile = _wfopen(filename, L"w");
		//fwprintf(pFile, sSQL[k]);
		//fclose(pFile);


	}

	delete [] dec;
	delete [] nFields;
	delete [] nosign;
	delete [] zerofill;

}

void CSSMySQLconn::CreateTable(LPCSTR TargetTable, int nCols, LPCSTR** sColInfo, BOOL testExist)
{
	CString sSQL, sClause;
	if (testExist)
		sSQL.Format(_T("CREATE TABLE IF NOT EXISTS `%s` (\n"), (CString) TargetTable);
	else
		sSQL.Format(_T("CREATE TABLE `%s` (\n"), (CString) TargetTable);
	
	for (int j=0; j<nCols; j++) {
		
		if ( j==(nCols-1) )
			sClause.Format(_T("`%s` %s\n)"), (CString) sColInfo[COL_NAME][j], (CString) sColInfo[COL_TYPE][j]);
		else
			sClause.Format(_T("`%s` %s,\n"), (CString) sColInfo[COL_NAME][j], (CString) sColInfo[COL_TYPE][j]);

		sSQL += sClause;

	}

	if (m_IsMySQL) {
		sSQL = sSQL + _T("\nENGINE=MYISAM;");
	}
	else {
		sSQL = sSQL + _T(";");
	}

	ExecuteSQL(sSQL);

}

void CSSMySQLconn::UpdateRecords(CString sFromTab, CString TargetTable, LPCSTR sWhereFld)
{

	CString sSQLExec, sSQLInit, sSQLBody, sWhereClause = _T(""), fldName, sqlitem, 
		prCaption;

	sSQLInit.Format(_T("UPDATE `%s`, `%s` SET "), TargetTable, sFromTab );
	
	if (sWhereFld!=NULL)
		sWhereClause.Format(_T(" WHERE `%s`.`%s`=`%s`.`%s`"), TargetTable, (CString) sWhereFld, sFromTab, (CString) sWhereFld );


	int fldType = 0, ctr = 0;
	ULONG fldSize = 0;

	CString sql; sql.Format(_T("SELECT * FROM `%s` LIMIT 1"), sFromTab);
	CStatSimRS rs( this, sql);

	UINT nFld = rs.GetFieldCount();

	try
	{	
		//construct SQL for the fields and records
		for (UINT j=0; j<nFld; j++) {
			fldName = rs.GetFieldName(j);
			CString sComp(sWhereFld);
			if (sComp.MakeLower()==fldName.MakeLower())
				continue;
			
			if (ctr==0) {
				sSQLBody.Format(_T("`%s`.`%s`=`%s`.`%s`"), TargetTable, fldName, sFromTab, fldName );
			}
			else {
				sSQLBody.Format(_T("%s, `%s`.`%s`=`%s`.`%s`"), sSQLBody, TargetTable, fldName, sFromTab, fldName );
			}
			ctr++;
		}
		
		sSQLExec = sSQLInit + sSQLBody
			+ sWhereClause + _T(";");
		
		//CString filename;
		//filename.Format(_T("d:\\update.sql"));
		//FILE *pFile = _wfopen(filename, L"w");
		//fwprintf(pFile, sSQLExec);
		//fclose(pFile);
		//AfxMessageBox(sSQLExec);

		ExecuteSQL(sSQLExec);
		
	}


	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}

}
void CSSMySQLconn::UpdateRecords(CStatSimRS *pFromRS, CString TargetTable, LPCSTR sWhereFld,
							   CStatSimWnd* pLabel, CStatSimBar* pProgBar)
{

	CString sSQLExec, sSQLInit, sSQLBody, sWhereClause = _T(""), fldName, sqlitem, 
		prCaption;

	sSQLInit = _T("UPDATE `") + TargetTable + _T("` SET ");
	
	if (sWhereFld!=NULL)
		sWhereClause.Format(_T(" WHERE %s="), (CString) sWhereFld);


	int fldType = 0;
	ULONG fldSize = 0;

	ULONG nRec = pFromRS->GetRecordCount();
	UINT nFld = pFromRS->GetFieldCount();

	//counters
	ULONG counter = 0, max = nRec;
	USHORT min = 0;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}

	if (nRec>0) {
		pFromRS->MoveFirst();
	}

	try
	{	
		//construct SQL for the fields and records
		for (ULONG i=0; i<nRec; i++) {
			for (UINT j=0; j<nFld; j++) {
				fldName = pFromRS->GetFieldName(j);
				
				if (j==0)
					sSQLBody = _T("`") + fldName + _T("`=");
				else
					sSQLBody = sSQLBody + _T(", `") + fldName + _T("`=");
				
				counter++;
				
				prCaption.Format(_T("StatSim: Updating record %d of %d to %s"), 
					i+1, nRec, TargetTable);
				m_sProgress = ConstChar(prCaption);		
				m_nPercent = ((float) (i+1)/(float) nRec)*100;
				
				if (pLabel!=NULL) {
					if (pLabel->GetSafeHwnd()) pLabel->SetText(ConstChar(prCaption));
				}
				
				if (pProgBar!=NULL) {
					if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);
				}
				
				//construct SQL for updating cases			
				sqlitem = pFromRS->SQLFldValue(j, (CString) "\"\"");
				//sqlitem.Replace("\\", "\\\\");

				sSQLBody = sSQLBody + sqlitem;
			}

			sSQLExec = sSQLInit + sSQLBody
				+ sWhereClause + pFromRS->SQLFldValue(sWhereFld, (CString) "\"\"") + _T(";");

			ExecuteSQL(sSQLExec);

			sSQLExec = _T("");
			
			pFromRS->MoveNext();
			
		}		

	}


	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}

}
void CSSMySQLconn::InsertRecords(daedata * pFromDta, LPCSTR* TargetTable, 
							   LPCSTR* pType, USHORT nTypes, 
							   CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
							   float limitMB, CString strIndex)
{
	//create table if necessary	
	CreateTable(pFromDta, TargetTable, pType, nTypes, strIndex);	
	
	CStringArray sSQLPacketAdj, sSQLInit, sSQLClause, sSQLFullClause, 
		sSQLClauseBch, sSQLExec, sSQLExecBch;


	sSQLPacketAdj.SetSize(nTypes);
	sSQLInit.SetSize(nTypes);
	sSQLClause.SetSize(nTypes);
	sSQLFullClause.SetSize(nTypes);
	sSQLClauseBch.SetSize(nTypes);
	sSQLExec.SetSize(nTypes);
	sSQLExecBch.SetSize(nTypes);

	CStringArray SQLtable, fldName, sqlitem, prCaption;

	SQLtable.SetSize(nTypes);
	fldName.SetSize(nTypes);
	sqlitem.SetSize(nTypes);
	prCaption.SetSize(nTypes);

	UINT *nCols, *nRows;
	ULONG *i, *j;

	nCols = new UINT[nTypes];
	nRows = new UINT[nTypes];
	i = new ULONG[nTypes];
	j = new ULONG[nTypes];
	

	//packet size settings////////////////////////////////////////////
	
	float bchlimit = limitMB*( pow( (float) 1024, (float) 2 ) );
	
	if (limitMB>1) {
		
		CString mapSQL;	
		mapSQL.Format(_T("SET max_allowed_packet = %d"), (ULONG) bchlimit);
		ExecuteSQL(mapSQL);

		AfxMessageBox(mapSQL);
	}

	//packet size settings////////////////////////////////////////////

	USHORT min = 0, batch = 0;
	
	//counters
	ULONG counter = 0, bchpacket, packet,
		max = pFromDta->nLines;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}

	/*
	if (!pLabel && !pProgBar) {
		CSphereProgress *pSphereProgress = new CSphereProgress();
	}
	*/

	for (USHORT k=0; k<nTypes; k++) {	
		sSQLPacketAdj[k] = _T("");
		sSQLInit[k] = _T("");
		sSQLClause[k] = _T("");
		sSQLFullClause[k] = _T("");
		sSQLClauseBch[k] = _T("");
		sSQLExec[k] = _T("");
		sSQLExecBch[k] = _T("");
		
		nCols[k] = pFromDta->colSize[k];
		nRows[k] = pFromDta->rowSize[k];

		SQLtable[k] = TargetTable[k];
		
		sSQLInit[k] = _T("INSERT INTO `") + SQLtable[k] + _T("`(`");
		
		//construct SQL for the fields
		
		for (ULONG b=0; b<nCols[k]; b++) {
			
			fldName[k] = pFromDta->pDict[k]->GetVarName(b);
			//packet = packet + pFromDta->pDict->GetVarBytes(j);	//inconsistent
			
			if (b == nCols[k] - 1) {
				sSQLInit[k] = sSQLInit[k] + fldName[k] + _T("`) \nVALUES ");
			}
			else {
				sSQLInit[k] = sSQLInit[k] + fldName[k] + _T("`,`");
			}
		}
		


		//bchpacket = packet;				//inconsistent
		//ensure initiated
		i[k]=0, j[k]=0;
		
		for (i[k]=0; i[k]<nRows[k]; i[k]++) {	
			//Reassign initial SQL to prepare for another record
			//reinitialize
			sSQLClause[k] = _T("");
			counter++; //batch++;
			//bchpacket = counter * packet; 			//inconsistent				
			
			prCaption[k].Format(_T("StatSim: Inserting record %d of %d to %s"), 
				i[k]+1, nRows[k], SQLtable[k]);
			
			m_sProgress = ConstChar(prCaption[k]);		
			m_nPercent = ((float) counter/(float) max)*100;
			
			if (pLabel!=NULL) {
				if (pLabel->GetSafeHwnd()) pLabel->SetText( ConstChar(prCaption[k]) );
			}				
			
			if (pProgBar!=NULL) {
				if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);
			}

			/*
			if (!pLabel && !pProgBar) {

				if(!pSphereProgress->Continue())
					return 1;
				CString strMessage;
				strMessage.Format(L"Progress: %i", m_nPercent);
				pSphereProgress->SetProgress(strMessage, (double)i/50.0f);
			}
			*/

			//construct SQL for adding cases
			for (j[k]=0; j[k]<nCols[k]; j[k]++) {
				

				sqlitem[k] = pFromDta->SQLItemValue(k, i[k], j[k], "\"\"")->c_str();	
				//AfxMessageBox(sF.c_str());
							
				//appendages
				if (nCols[k]==1) {
					sSQLClause[k] = _T("(") + sqlitem[k] + _T(")");
				}
				
				else {
					if (j[k] == 0) {
						sSQLClause[k] = _T("(") + sqlitem[k] + _T(",");					
					}
					else if (j[k] == (nCols[k] - 1)) {
						sSQLClause[k] = sSQLClause[k] + sqlitem[k] + _T(")");
					}				
					else {
						sSQLClause[k] = sSQLClause[k] + sqlitem[k] + _T(",");
					}
				}

				//AfxMessageBox(sSQLClause[k]);

			}
	
			sSQLExecBch[k] = sSQLInit[k] + sSQLClauseBch[k];
			
			packet = sSQLExecBch[k].GetLength();	//get the size of the previous full batch SQL
			bchpacket = sSQLClause[k].GetLength();	//get the size of the current clause
			
			if ( packet + bchpacket > (bchlimit-8) ) {
				sSQLExecBch[k] = sSQLExecBch[k] + _T(";\n");

				//CString filename;
				//filename.Format(_T("d:\\append%d.sql"), k);
				//FILE *pFile = _wfopen(filename, L"w");
				//fwprintf(pFile, sSQLExecBch[k]);
				//fclose(pFile);
							
				//AfxMessageBox(sSQLExecBch[k]);
				ExecuteSQL(sSQLExecBch[k]);
				
				sSQLExecBch[k] = _T("");	//reset
				sSQLClauseBch[k] = _T("");	//reset
				
				//reassign current clause since it is not included in the execution
				sSQLClauseBch[k] = sSQLClauseBch[k] + sSQLClause[k];
			}
			
			else {
				
				if (i[k] == nRows[k]-1) {

					if (nRows[k]==1) {
						sSQLExecBch[k] = sSQLExecBch[k] + sSQLClause[k] + _T(";\n");

						//CString filename;
						//filename.Format(_T("c:\\append%d.sql", k);
						//FILE *pFile = fopen(filename, "w");
						//fprintf(pFile, sSQLExecBch[k]);
						
						
						//AfxMessageBox(sSQLExecBch[k]);						
						ExecuteSQL(sSQLExecBch[k]);
						sSQLExecBch[k] = _T("");	//reset
						sSQLClauseBch[k] = _T("");	//reset
					
					}

					else {
						//append the last clause						
						sSQLExecBch[k] = sSQLExecBch[k] + _T(",\n") + sSQLClause[k] + _T(";\n");
																	
						//AfxMessageBox(sSQLExecBch[k]);
						ExecuteSQL(sSQLExecBch[k]);
						sSQLExecBch[k] = _T("");	//reset
						sSQLClauseBch[k] = _T("");	//reset
					}
				}
				
				else {
					
					if (i[k]==0) {
						sSQLClauseBch[k] = sSQLClauseBch[k] + sSQLClause[k];
					}
					else {
						sSQLClauseBch[k] = sSQLClauseBch[k] + ",\n" + sSQLClause[k];
					}
				
				}
			}
		}
	}

	delete [] nCols;
	delete [] nRows;
	delete [] i;
	delete [] j;

}

void CSSMySQLconn::InsertRecords(LPCSTR sPath, daedict **pDict, LPCSTR* TargetTable, int rtLen, 
		LPCSTR* pType, USHORT nTypes, 
		CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
		float limitMB, CString strIndex)
{
	//create table if necessary	
	CreateTable(pDict, TargetTable, pType, nTypes, strIndex);	
	
	//CStringArray sSQLPacketAdj, sSQLInit, sSQLClause, sSQLFullClause, 
	//	sSQLClauseBch, sSQLExec, sSQLExecBch;
	CStringArray sSQLInit, sSQLClause, sSQLExecBch;

	//map ntypes
	//std::map<wstring, unsigned short> mapType;
	std::map<string, unsigned short> mapType;
	//std::map<wstring, unsigned short> wmapType;
	 
	//pass
	for (USHORT m=0; m<nTypes; m++) {
		string sT(pType[m]);
		mapType.insert(std::pair<string, USHORT>(sT, m));
	}


	//sSQLPacketAdj.SetSize(nTypes);
	//sSQLFullClause.SetSize(nTypes);
	//sSQLClauseBch.SetSize(nTypes);
	//sSQLExec.SetSize(nTypes);
	sSQLInit.SetSize(nTypes);
	sSQLClause.SetSize(nTypes);
	sSQLExecBch.SetSize(nTypes);

	CStringArray SQLtable, fldName, sqlitem, prCaption;

	SQLtable.SetSize(nTypes);
	fldName.SetSize(nTypes);
	sqlitem.SetSize(nTypes);
	prCaption.SetSize(nTypes);

	UINT *nCols, *nI;
	ULONG *nRows;

	nCols = new UINT[nTypes];
	nI = new UINT[nTypes];
	nRows = new ULONG[nTypes];

	
	for (USHORT k=0; k<nTypes; k++) {	
		nCols[k] = pDict[k]->nVars(); //nRows unknown yet
		nRows[k] = 0;
		nI[k] = 0;
		SQLtable[k] = _T("");
		sSQLInit[k] = _T("");
		sSQLClause[k] = _T("");
		sSQLExecBch[k] = _T("");
		//sSQLExec[k] = _T("");
		//sSQLPacketAdj[k] = _T("");
		//sSQLFullClause[k] = _T("");
		//sSQLClauseBch[k] = _T("");
		
		//construct SQL for the fields
	
		SQLtable[k] = TargetTable[k];
		
		sSQLInit[k] = _T("INSERT INTO `") + SQLtable[k] + _T("`(`");

		for (UINT b=0; b<nCols[k]; b++) {
			
			fldName[k] = pDict[k]->GetVarName(b);
			//packet = packet + pFromDta->pDict->GetVarBytes(j);	//inconsistent
			
			if (b == nCols[k] - 1) {
				sSQLInit[k] = sSQLInit[k] + fldName[k] + _T("`) \nVALUES ");
			}
			else {
				sSQLInit[k] = sSQLInit[k] + fldName[k] + _T("`,`");
			}
		}

		sSQLExecBch[k] = sSQLInit[k];//batch SQL

	}

	
	//packet size settings////////////////////////////////////////////
	
	float bchlimit = limitMB*( pow( (float) 1024, (float) 2 ) );
	
	if (limitMB>1) {
		
		CString mapSQL;	
		mapSQL.Format(_T("SET max_allowed_packet = %d"), (ULONG) bchlimit);
		ExecuteSQL(mapSQL);

		//AfxMessageBox(mapSQL);
	}

	//packet size settings////////////////////////////////////////////

	USHORT min = 0, batch = 0;
	
	//counters
	ULONG packet, max = 0;//pFromDta->nLines;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}

	/*
	if (!pLabel && !pProgBar) {
		CSphereProgress *pSphereProgress = new CSphereProgress();
	}
	*/
	

	//CString msg; msg.Format(_T("Please: %s"), (CString) sPath);
	//AfxMessageBox(msg);

	//open stream
	//ifstream inf(sPath, ios::in | ios::binary);
	//inf.imbue(std::locale(wif.getloc(), new std::codecvt_utf16<wchar_t, 0x10ffff, std::consume_header>));
	//std::locale utf8_locale(std::locale(), new gel::stdx::utf8cvt<true>);
	//inf.imbue(utf8_locale);
	wifstream winf;
	ifstream inf(sPath, ios::in | ios::binary);
	
	//wifstream inf(sPath);

	int nCh = 0, cpos = 0, nlines = 0, loc_rtpos = rt_pos;
	//detect encoding, if UTF-8, seekg
	//wchar_t wbuffer[10];
	char buffer[10];
	inf.read(buffer, 3);
	//wcstombs(buffer,wbuffer,10);
	//if (buffer[0] == 0XEF && buffer[1] == 0XBB && buffer[2] == 0XBF) {
	if (buffer[0] == '\xEF' && buffer[1] == '\xBB' && buffer[2] == '\xBF') {
		//deprecated, just set locale
		winf.close();
		winf.imbue(stdx::utf8_locale); 
		winf.open(sPath, ios::in | ios::binary);	
		//inf.seekg(0);
		//inf.open(sPath, ios::in | ios::binary);
		//offset cpos
		cpos=1;
		//AfxMessageBox(L"unicode");
		inf.close();

	}
	else {
		winf.close();
		winf.open(sPath);
		winf.seekg(0);
		//revise rt_pos
		loc_rtpos = rt_pos-1;
		//AfxMessageBox(L"not unicode");
		inf.close();
	}
		//inf.close();
		//inf.imbue(stdx::utf8_locale); 
		//inf.open(sPath);	

	//string line;
	//string::size_type len;
	wstring wline;
	wstring::size_type len;
	//char *rt = new char[rtLen+1];
	//std::string narrow(
	//set locale
	//while(!std::getline(inf, line, '\n').eof()) {
	while(!getline(winf, wline).eof()) {

		//CString msg;
		//msg.Format(_T("pos: %d, len: %d, text: %s"), cpos, len, (CString) wline.c_str());
		//AfxMessageBox(msg);

		nlines++;
		len = wline.length();
		if (!len)	//skip the line if zero length
			continue;

		//for (int r=(rt_pos-1); r<(rt_pos+rtLen-1); r++) {	//incorporating the position of the record type
		//	rt[r] = line[r]; //get the record type characters/text
		//}
		//TODO: make this more efficient
		wstring w_rt;
		if (nlines>1)
			w_rt.assign(wline.substr(rt_pos-1, rtLen));
		else
			w_rt.assign(wline.substr(loc_rtpos, rtLen));
		//string rt(ConstChar(sbuff));
		string rt(w_rt.begin(),w_rt.end());

		//CString strmsg;
		//strmsg.Format(_T("pos:%d, len: %d, wide: %s, narrow: %s"), loc_rtpos, rtLen, (CString) w_rt.c_str(), (CString)rt.c_str());
		//AfxMessageBox(strmsg);

		if (rtLen>1) {
			int zpos = rt.find_first_not_of("0");
			
			if (zpos!=string::npos)
				rt.erase(0, rt.find_first_not_of("0"));
			else
				rt.assign("0");
		
		}

		//if (!rt)	//skip if null record type
		//	continue;
		if (rt.empty())	//skip if null record type
			continue;

		//rt[rtLen]='\0'; //null terminated

		//USHORT idx = GetIDX( pType, nTypes, rt, rtLen, true); //idx = index of rt
		USHORT idx = mapType[rt]; //idx = index of rt
		//idx = wmapType[w_rt];
		//CString msg;
		//msg.Format(_T("pos: %d; len: %d; rt: %s; idx: %d; line: %s"), rt_pos-1, rtLen, (CString) rt.c_str(), idx, (CString) line.c_str());
		//AfxMessageBox(msg);

		nRows[idx]++; //increment number of records in idx;
		nI[idx]++; //increment util counter

		sSQLClause[idx] = _T(""); //every new case, new clause?

		for (int h=0; h<nCols[idx]; h++) {
	
			int clen = atoi(pDict[idx]->GetVarLen(h)); 
			std::string currVal;

			if ( !ExtCh(wline, currVal, cpos, clen) ) {	//get value
				currVal = "";
			}

			//CString msg;
			//msg.Format(_T("pos: %d, len: %d, text: %s"), cpos, clen, (CString) currVal.c_str());
			//AfxMessageBox(msg);

			
			//TODO: UTF8 encoding! 
			sqlitem[idx] = sql_itm_val(currVal.c_str(), pDict, idx, h, "\"\"").c_str();	
			//AfxMessageBox(sqlitem[idx]);
			
			//appendages
			if (nCols[idx]==1) {
					sSQLClause[idx] = _T("(") + sqlitem[idx] + _T(")");
			}
			
			else {
				if (h == 0) {
					sSQLClause[idx] = _T("(") + sqlitem[idx] + _T(",");		
				}
				else if (h == (nCols[idx] - 1)) {
					sSQLClause[idx] = sSQLClause[idx] + sqlitem[idx] + _T(")");
				}				
				else {
					sSQLClause[idx] = sSQLClause[idx] + sqlitem[idx] + _T(",");
				}
			}
			

			cpos += clen;
			clen = 0;


		}
		
		//AfxMessageBox(sSQLClause[idx]);
		if (nI[idx]>1) //test if single record
			sSQLExecBch[idx] += _T(", ") + sSQLClause[idx];
		else
			sSQLExecBch[idx] += sSQLClause[idx];
		

		packet = sSQLExecBch[idx].GetLength();	//get the size of the previous full batch SQL

		if ( 1.5*packet > (bchlimit-8) ) {
			sSQLExecBch[idx] = sSQLExecBch[idx] + _T(";\n");
			
			ExecuteSQL(sSQLExecBch[idx]);
			//AfxMessageBox(sSQLExecBch[idx]);
				
			sSQLExecBch[idx] = sSQLInit[idx];	//reset
			nI[idx] = 0;
				
		}

		wline.clear();
		cpos = 0; //reset


	}
	

	//CString filename;
	for (USHORT k=0; k<nTypes; k++) {		
		
		if (nI[k]>0) {
			sSQLExecBch[k] = sSQLExecBch[k] + _T(";\n");
			ExecuteSQL(sSQLExecBch[k]);
		}

		//CString filename;
		//filename.Format(_T("c:\\append%d.sql"), k);
		//FILE *pFile = _tfopen(filename, _T("w"));
		//_ftprintf(pFile, sSQLExecBch[k]);
		//fclose(pFile);
	}

	delete [] nCols;
	delete [] nRows;
	delete [] nI;

	winf.close(); //close the stream

}
void CSSMySQLconn::InsertRecords(LPCSTR** sArray, LPCSTR TargetTable, 
							  long nRows, int nCols, LPCSTR** sColInfo, 
							  CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
							  BOOL fresh, BOOL single, BOOL ignore)
{
	
	//CreateTable(TargetTable, nCols, sColInfo);

	CString sSQLExec, sSQLInit = _T(""), sSQLField = _T(""), sSQLValue = _T(""), fldName, sqlitem, 
		sAlias, prCaption;

	//test for number of records
	CStatSimRS *pRS = new CStatSimRS(this, TargetTable);
	if (pRS->GetRecordCount()>0 && fresh==TRUE)
		return;
	delete pRS; pRS = NULL;

	if (ignore) {
		sSQLInit = _T("INSERT IGNORE INTO `") + (CString) TargetTable + _T("`(");
	}
	else {
		sSQLInit = _T("INSERT INTO `") + (CString) TargetTable + _T("`(");
	}

	int fldType = 0;
	ULONG fldSize = 0;

	//counters
	ULONG counter = 0, max = nRows;
	USHORT min = 0;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}
	
	UINT nCols_new = 0;
	
	if (!m_IsMySQL){
		if (nCols>=MAX_COL_MDB) {
			nCols_new = MAX_COL_MDB;
			CString msg;
			msg.Format(_T("Warning: Only %d columns of %d could be transferred to the current database."), 
				MAX_COL_MDB, nCols );
			AfxMessageBox(msg);
		}
		else {
			nCols_new = nCols;
		}
	}
	else {
		nCols_new = nCols;
	}
	
	//construct SQL for the fields
	for (UINT j=0; j<nCols_new; j++) {
		
		sColInfo[COL_TYPE][j];
		
		fldName = sColInfo[COL_NAME][j];
		
		if ( j==nCols_new-1 )
			sSQLField = sSQLField + _T("`") + fldName + _T("`) \nVALUES ");
		else
			sSQLField = sSQLField + _T("`") + fldName + _T("`, ");
	
	}
	
	for (ULONG i=0; i<nRows; i++) {
		counter++;
		
		prCaption.Format(_T("StatSim: Inserting record %d of %d to %s"), 
			counter, max, (CString) TargetTable);
		m_sProgress = ConstChar(prCaption);		
		m_nPercent = ((float) counter/(float) max)*100;
		
		if (pLabel!=NULL) {
			if (pLabel->GetSafeHwnd()) pLabel->SetText( ConstChar(prCaption) );
		}				
		
		if (pProgBar!=NULL) {
			if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);
		}
		
		//construct SQL for adding cases
		for (UINT j=0; j<(UINT)nCols_new; j++) {
			
			if (single) {
				//temporary handler
				CString sTemp(sArray[i][j]);
				
				if (strcmp(sColInfo[COL_NUM][j], NUMERIC)!=0) { //compare
					sTemp.Replace(_T("\\"), _T("\\\\"));	//replace backslash
					//sTemp.Replace(_T("\'"), _T("\\\'"));	//replace single quotes
					sTemp = _T("\'") + sTemp + _T("\'");
				}

				int sLen = sTemp.GetLength();

				//get the enclosed string
				//pass new stemp
				if (sTemp.Left(1)=="'" && sTemp.Right(1)=="'") {
					sTemp = sTemp.Left(sLen-1);
					sLen = sTemp.GetLength();
					sTemp = sTemp.Right(sLen-1);
					
					//this is for ms jet that cannot insert single quotes
					sTemp.Replace( _T("'"), _T("''") );
					
					//reassign
					sqlitem = _T("'") + sTemp + _T("'");
				}
				else {
					sqlitem = sTemp;
				}
			}
			
			else {
				//temporary handler
				sqlitem = sArray[i][j];

				if (strcmp(sColInfo[COL_NUM][j], NUMERIC)!=0) { //compare
					sqlitem.Replace(_T("\\"), _T("\\\\"));	//replace backslash
					//sTemp.Replace(_T("\'"), _T("\\\'"));	//replace single quotes
					sqlitem = _T("\"") + sqlitem + _T("\"");
				}
			}
			//appendages
			if (j == 0) {
				sSQLValue = sSQLValue + _T("(") + sqlitem + _T(", ");
			}
			//if there is only one field
			else if ((j == nCols_new - 1) || 
				(nCols_new - 1 == 0)) {
				sSQLValue = sSQLValue + sqlitem + _T(")");
			}
			
			else {
			
				sSQLValue = sSQLValue + sqlitem + _T(", ");
			
			}
		}

		if ( i < (nRows-1) ) { //not EOF
			if (single) {
				sSQLValue = sSQLValue + _T(";\n");
				sSQLExec = sSQLInit + sSQLField + sSQLValue;
				
				ExecuteSQL( sSQLExec );
				sSQLExec = _T("");
				sSQLValue = _T("");
			}
			else {
				sSQLValue = sSQLValue + _T(", \n");
			}
		}
		else {
			if (single) {
				sSQLValue = sSQLValue + _T(";\n");
				sSQLExec = sSQLInit + sSQLField + sSQLValue;
				ExecuteSQL( sSQLExec );
				sSQLExec = _T("");
				sSQLValue = _T("");
				
			}
			
			else {
				sSQLValue = sSQLValue + _T(";\n");
			}				
		}
	}
	
	sSQLExec = sSQLInit + sSQLField + sSQLValue;
	if (!single)
		ExecuteSQL( (sSQLExec) );

}

void CSSMySQLconn::InsertFromSQL(CString sFromSQL, CString TargetTable)
{
	CString sSQLExec, sSQLInit = _T(""), 
		sSQLField = _T(""), 
		sSQLValue = _T(""), 
		sSQLClause = _T(""), 
		fldName, sqlitem, 
		sAlias, prCaption;
		
	sSQLInit = _T("INSERT IGNORE INTO `") + TargetTable + _T("`(");

	//CString sql; sql.Format(_T("SELECT * FROM `%s` LIMIT 0;"), TargetTable);
	CStatSimRS rs( this, sFromSQL);

	UINT nFld = rs.GetFieldCount();

	//construct SQL for the fields and records
	for (UINT j=0; j<nFld; j++) {
		fldName = rs.GetFieldName(j);
		if (j==0) {
			sSQLField.Format(_T("`%s`"), fldName );
		}
		else {
			sSQLField.Format(_T("%s, `%s`"), sSQLField, fldName );
		}

	}

	sSQLExec = sSQLInit + sSQLField + _T(") ") + sFromSQL;

	//FILE* pFile = _tfopen(_T("d:\\mycmd.sql"), _T("w"));
	//_ftprintf(pFile, sSQLExec);
	//fclose(pFile);

	ExecuteSQL(sSQLExec);

}
void CSSMySQLconn::InsertRecords(CStatSimRS *pFromRS, CString TargetTable,
							   CStatSimWnd* pLabel, CStatSimBar* pProgBar,
							   BOOL fresh, BOOL single, BOOL ignore, 
							   LPCSTR sCritFld, LPCSTR* sCritVals, int nItems)
{

	CString sSQLExec, sSQLInit = _T(""), 
		sSQLField = _T(""), 
		sSQLValue = _T(""), 
		sSQLClause = _T(""), 
		fldName, sqlitem, 
		sAlias, prCaption;

	//test for number of records
	CString sql = _T("SELECT * FROM `") + TargetTable + _T("`;");
	mysqlpp::StoreQueryResult* res = OpenSQL(sql);

	if (res->size()>0 && fresh==TRUE) {
		//res->purge();
		res->clear();
		delete res; res = 0;
		return;
	}

	if (ignore) {
		sSQLInit = _T("INSERT IGNORE INTO `") + TargetTable + _T("`(");
	}
	else {
		sSQLInit = _T("INSERT INTO `") + TargetTable + _T("`(");
	}

	int fldType = 0;
	ULONG fldSize = 0;

	ULONG ct = pFromRS->GetRecordCount();

	//counters
	ULONG counter = 0, max = ct;
	USHORT min = 0;

	if (pProgBar!=NULL) {
		pProgBar->SetRange(0, 100);
	}

	if (ct>0) {
		pFromRS->MoveFirst();
	}

	try
	{	
		//construct SQL for the fields
		for (UINT j=0; j<pFromRS->GetFieldCount(); j++) {
			
			fldName = pFromRS->GetFieldName(j);
			
			if ( j==pFromRS->GetFieldCount()-1 )
				sSQLField = sSQLField + _T("`") + fldName + _T("`) \nVALUES ");
			else
				sSQLField = sSQLField + _T("`") + fldName + _T("`, ");
		
		}
		
		for (ULONG i=0; i<(ULONG)pFromRS->GetRecordCount(); i++) {			

			if (sCritFld!=NULL && sCritVals!=NULL) {
				LPCSTR sCrit = ConstChar(pFromRS->SQLFldValue(sCritFld));
				if ( !Exists(sCritVals, sCrit, nItems) ) {
					pFromRS->MoveNext();
					continue;
				}
			}
	
			counter++;
			
			prCaption.Format(_T("StatSim: Inserting record %d of %d to %s"), 
				counter, max, (CString) TargetTable);
			m_sProgress = ConstChar(prCaption);		
			m_nPercent = ((float) counter/(float) max)*100;
			
			if (pLabel!=NULL) {
				if (pLabel->GetSafeHwnd()) pLabel->SetText(ConstChar(prCaption));
			}				
			
			if (pProgBar!=NULL) {
				if (pProgBar->GetSafeHwnd()) pProgBar->SetPos((int) m_nPercent);
			}

			//refresh the current row
			pFromRS->Refresh();

			//construct SQL for adding cases
			for (UINT j=0; j<pFromRS->GetFieldCount(); j++) {
				
				if (single)
					sqlitem = pFromRS->SQLFldValue(j, (CString) "\'\'", TRUE, TRUE);
				else
					sqlitem = pFromRS->SQLFldValue(j, (CString) "\"\"");

				//appendages
				if (j == 0) {
					sSQLClause = sSQLClause + _T("(") + sqlitem + _T(", ");
				}

				//if there is only one field
				else if ((j == pFromRS->GetFieldCount() - 1) ||
					(pFromRS->GetFieldCount() - 1 == 0)) {
					
					sSQLClause = sSQLClause + sqlitem + _T(")");

				}				
				else {
					sSQLClause = sSQLClause + sqlitem + _T(", ");
				}		

			}
					
			pFromRS->MoveNext();

			if (single) {
				sSQLClause = sSQLClause + _T(";\n");
				sSQLExec = sSQLInit + sSQLField + sSQLClause;
				
				//FILE* pFile = _tfopen(_T("C:\\mycmd.sql"), _T("w"));
				//_ftprintf(pFile, ConstChar(sSQLExec));
				//fclose(pFile);

				ExecuteSQL( (sSQLExec) );
				sSQLExec = _T("");
				sSQLClause = _T("");
			}
			else {
				if (counter>1) {
					sSQLValue = sSQLValue + _T(", \n") + sSQLClause;
					sSQLClause = _T("");
				}
				else {
					sSQLValue = sSQLClause;
					sSQLClause = _T("");
				}
			}
		}

		sSQLExec = sSQLInit + sSQLField + sSQLValue + _T(";");
		
		
		if (!single) {
			ExecuteSQL( (sSQLExec) );
		}

	}


	catch(_com_error &e) 
	{		
		_bstr_t bstrSource (e.Source());
		_bstr_t bstrDescription (e.Description());
		TRACE ( "Exception thrown for classes generated by #import" );
		TRACE ( "\tCode = %08lx\n", e.Error ());
		TRACE ( "\tCode meaning = %s\n", e.ErrorMessage ());
		TRACE ( "\tSource = %s\n", (LPCSTR) bstrSource);
		TRACE ( "\tDescription = %s\n", (LPCSTR) bstrDescription);

		AfxMessageBox ((LPCTSTR) bstrDescription);
	}

}


CStatSimConn::CStatSimConn()
{

}

CStatSimConn::CStatSimConn(CString custUser, CString custPwd,
		CString custHost, CString custPort, LPCSTR custDB,
		bool ODBC, bool IsMySQL)
{

	m_IsMySQL = IsMySQL;

	m_IsODBC = ODBC;

	if (m_IsODBC) {
		//ODBC
		pMySQLdb = 0;
		pODBCdb = new CSSODBCconn(custUser, custPwd, custHost, custPort, custDB, IsMySQL);
	}
	else {
		//MySQL
		pODBCdb = 0;
		pMySQLdb = new CSSMySQLconn(custUser, custPwd, custHost, custPort, custDB);
	}


}

CStatSimConn::CStatSimConn(CString strConn, bool IsMySQL)
{
	
	m_IsMySQL = IsMySQL;

	//string connection is for ODBC only
	m_IsODBC = TRUE;

	pMySQLdb = 0;
	pODBCdb = new CSSODBCconn(strConn, IsMySQL);

}

CStatSimConn::~CStatSimConn()
{

	delete pMySQLdb; pMySQLdb = 0;
	delete pODBCdb; pODBCdb = 0;

}

short CStatSimConn::ExecuteSQL(CString sSQL, BOOL prompt)
{

	if (m_IsODBC) {
		return pODBCdb->ExecuteSQL(sSQL, prompt);
	}
	else {
		return pMySQLdb->ExecuteSQL(sSQL, prompt);
	}

}

void CStatSimConn::CreateTable(CStatSimRS * pFromRS, CString TableName, 
		BOOL conservative, BOOL testExist, BOOL encloseFld)
{

	if (m_IsODBC) {
		pODBCdb->CreateTable(pFromRS, TableName, conservative, testExist, encloseFld);
	}
	else {

		//AfxMessageBox(TableName);
		pMySQLdb->CreateTable(pFromRS, TableName, conservative, testExist, encloseFld);
	}

}

void CStatSimConn::CreateTable(daedata *pFromDta, LPCSTR* TableName, 
		LPCSTR* pType, USHORT nTypes, CString strIndex)
{

	if (m_IsODBC) {
		pODBCdb->CreateTable(pFromDta, TableName, pType, nTypes, strIndex);
	}
	else {
		pMySQLdb->CreateTable(pFromDta, TableName, pType, nTypes, strIndex);	//wala pa
	}

}
void CStatSimConn::CreateTable(daedict **pDCT, LPCSTR* pTables, 
		LPCSTR* pType, USHORT nTypes, CString strIndex)
{

	if (m_IsODBC) {
		AfxMessageBox(_T("Feature unavailable."));
	}
	else {
		pMySQLdb->CreateTable(pDCT, pTables, pType, nTypes, strIndex);	//wala pa
	}

}

void CStatSimConn::UpdateRecords(CString sFromTab, CString TargetTable, LPCSTR sWhereFld)
{

	if (m_IsODBC) {
		AfxMessageBox(_T("Direct update not available in ODBC"));
	}
	else {
		pMySQLdb->UpdateRecords(sFromTab, TargetTable, sWhereFld);
	}

}
void CStatSimConn::UpdateRecords(CStatSimRS * pFromRS, CString TargetTable, LPCSTR sWhereFld,
		CStatSimWnd* pLabel, CStatSimBar* pProgBar)
{

	if (m_IsODBC) {
		pODBCdb->UpdateRecords(pFromRS, TargetTable, sWhereFld, pLabel, pProgBar);
	}
	else {
		pMySQLdb->UpdateRecords(pFromRS, TargetTable, sWhereFld, pLabel, pProgBar);	//wala pa
	}

}

void CStatSimConn::CreateTable(LPCSTR TargetTable, int nCols, LPCSTR** sColInfo, BOOL testExist)
{
	if (m_IsODBC) {
		pODBCdb->CreateTable(TargetTable, nCols, sColInfo, testExist);
	}
	else {
		pMySQLdb->CreateTable(TargetTable, nCols, sColInfo, testExist);
	}

}

void CStatSimConn::InsertFromSQL(CString sFromSQL, CString TargetTable)
{

	if (m_IsODBC) {
		AfxMessageBox(_T("Direct update not available in ODBC"));
	}
	else {
		pMySQLdb->InsertFromSQL(sFromSQL, TargetTable);
	}

}

void CStatSimConn::InsertRecords(LPCSTR** sArray, LPCSTR TargetTable, 
		long nRows, int nCols, LPCSTR** sColInfo, 
		CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
		BOOL fresh, BOOL single, BOOL ignore)

{
	if (m_IsODBC) {
		pODBCdb->InsertRecords(sArray, TargetTable, nRows, nCols, sColInfo,
			pLabel, pProgBar, fresh, single, ignore);
	}
	else {
		pMySQLdb->InsertRecords(sArray, TargetTable, nRows, nCols, sColInfo,
			pLabel, pProgBar, fresh, single, ignore);
	}

}

void CStatSimConn::InsertRecords(CStatSimRS * pFromRS, CString TargetTable,
		CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
		BOOL fresh, BOOL single, BOOL ignore,
		LPCSTR sCritFld, LPCSTR* sCritVals, int nItems)
{

	if (m_IsODBC) {
		pODBCdb->InsertRecords(pFromRS, TargetTable, pLabel, pProgBar, fresh, single, ignore, sCritFld, sCritVals, nItems);
	}
	else {
		pMySQLdb->InsertRecords(pFromRS, TargetTable, pLabel, pProgBar, fresh, single, ignore, sCritFld, sCritVals, nItems);	//wala pa
	}

}

void CStatSimConn::InsertRecords(daedata * pFromDta, LPCSTR* TargetTable, 
		LPCSTR* pType, USHORT nTypes, 
		CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
		float limitMB, CString strIndex)
{

	if (m_IsODBC) {
		pODBCdb->InsertRecords(pFromDta, TargetTable, pType, nTypes, 
			pLabel, pProgBar, limitMB, strIndex);
	}
	else {
		pMySQLdb->InsertRecords(pFromDta, TargetTable, pType, nTypes, 
			pLabel, pProgBar, limitMB, strIndex);	//wala pa
	}

}
void CStatSimConn::InsertRecords(LPCSTR sPath, daedict **pDCT, LPCSTR* pTables, int rtLen, 
		LPCSTR* pType, USHORT nTypes, 
		CStatSimWnd* pLabel, CStatSimBar* pProgBar, 
		float limitMB, CString strIndex)
{

	if (m_IsODBC) {
		AfxMessageBox(_T("Feature unavailable."));
	}
	else {
		pMySQLdb->InsertRecords(sPath, pDCT, pTables, rtLen, pType, nTypes, 
			pLabel, pProgBar, limitMB, strIndex);	
	}

}
CString CStatSimConn::CreateSQL(USHORT index)
{

	if (m_IsODBC) {
		return pODBCdb->CreateSQL(index);
	}
	else {
		return pMySQLdb->CreateSQL(index);	//wala pa
	}

}

CSSODBCconn* CStatSimConn::GetODBCdb()
{

	return pODBCdb;

}

CSSMySQLconn* CStatSimConn::GetMySQLdb()
{
	return pMySQLdb;

}

BOOL CStatSimConn::IsConnected()
{

	if (m_IsODBC) {
		return pODBCdb->IsConnected();
	}
	else {
		return pMySQLdb->IsConnected();
	}

}
bool CStatSimConn::IsODBC()
{

	return m_IsODBC;

}

bool CStatSimConn::IsMySQL()
{

	return m_IsMySQL;

}
bool CStatSimConn::GetTableList(std::vector<LPCSTR> &tables)
{
	if (m_IsODBC) {
		AfxMessageBox(_T("Not available for ODBC connection"));
		return 0;
	}

	CString sSQL = _T("SHOW TABLES;");
	CStatSimRS *pRS = 0;

	pRS = new CStatSimRS(this, sSQL);
	int nRec = pRS->GetRecordCount();
	if (nRec>0) {
		pRS->MoveFirst();
	}
	else{
		return 0;
	}

	for (int i=0; i<nRec; i++) {
		CString str = pRS->SQLFldValue((USHORT) 0);
		
		tables.push_back(ConstChar(str));		
		pRS->MoveNext();
	}

	delete pRS;

	return 1;
}

